<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Effective Objective-C 2.0——读书笔记]]></title>
    <url>%2F2018%2F05%2F07%2FEffective%20Objective%E2%80%94%E2%80%94C%202.0%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[二刷，记录一些自己认为重要的东西。 Effective Objective-C 2.0——读书笔记1、开始 字面量语法更安全。 `如下： NSAarry *arrayA = [NSArray arrayWithObjects:@&quot;1&quot;,nil,@&quot;2&quot;,nil]; NSAarry *arrayB = @[@&quot;1&quot;,nil,@&quot;2&quot;,nil]; 此时arrayA不会报错，但创建出来的元素会少掉，因为arrayWithObjects方法会依次处理各个参数，直到发现nil为止。 arrayB会直接抛出异常。 不要用预处理指令定义常量。这样定义出来的常量不仅没有类型信息，当有人重新定义了常量值，编译器也不会产生警告，这样会导致应用程序中的常量值不一致。 如果试图修改由const修饰符所声明的变量，那么编译器会报错。 static修饰符意味着该变量仅在定义此变量的编译单元中可见。 `应该如下声明常量： .h文件中 extern NSTimeInterval const LLZStaticShowTime; .m文件中 const NSTimeInterval LLZStaticShowTime = 1.0; 枚举可表示状态、选项、状态码。凡是需要以按位或操作来组合的枚举都应使用NS_OPTIONS定义，否则编译器会报错。 strong 和 copy 的区别在于 strong是保留新值，释放旧值，在讲新值设置上去，而copy是将新值拷贝一份，为了保护其封装性。 weak 和 unsafe_unretained的区别在于 当所指的对象销毁的时候，weak 修饰的属性值会被置为nil，而后者不会自动清空，这个时候可能会发生野指针。 atomic 会通过锁定机制确保其操作的原子性。但是在iOS中使用同步锁的开销较大，而且atomic并不能保证线程安全，例如：一个线程在连续多次读取某属性值的过程中，另一线程在同时改写该值，那么即便将属性声明为atomic，也还是会读取到不同的属性值。因此在iOS开发中 我们一般使用nonatmoic。 7、属性访问和直接访问的差别 点语法需要经过方法派发，如self.age = @18 等价于 [self setAge: @18]；而_age = @18是直接访问保存对象实例变量的那块内存。 直接访问实例变量，不会调用“设置方法”，这就绕过了相关属性所定义的内存管理语义。 直接访问实例变量，不会触发KVO 总结：通过属性访问有助于排查与之相关的错误，因为可以在get/set方法设置断点，但是直接访问实例变量速度更快。 8、对象等同性 若想检测对象的等同性，需提供“isEqual:”与hash方法，编写hash方法时，应该使用计算速度快而且哈希码碰撞几率低的算法（对关键属性的hash值进行位或运算作为hash的值）。 9、类族 类族模式可以把实现细节隐藏在一套简单的公共接口后面。 11、消息传递 objc msgSend stret 处理返回为结构体的消息，只有当CPU的寄存器能够容纳得下消息返回类型时，这个函数才能处理此消息，否则交由另一个函数执行派发。 objc msgSend fpret 处理返回是浮点数的消息， objc_ msgSendSuper 如果要给超类发送消息，那么就交由该函数处理。 当函数的最后一个操作仅仅是调用其他函数而不会将其返回值另作他用时，才能执行尾调用优化，不这么做的话，有可能会过早的发生”栈溢出“现象。 12、消息转发机制 动态方法解析：对象在收到无法解读的消息后，首先将调用其所属类的以下方法：查看该类是否可以动态新增方法以处理此选择子。（举例：此方案常用来实现@dynamic属性） (BOOL)resolveInstanceMethod:(SEL)selecor（实例方法） (BOOL)resolveClassMethod:(SEL)selecor（类方法） 备援接受者：运行期系统会问该类能不能把这条消息转给其他接受者来处理。处理方法如下。（举例：模拟出”多重继承“，返回能够处理某选择子的相关内部对象，外部看来，好像是该对象亲自处理了这些消息）。 (id)forwardingTargetForSelector:(SEL)selector 完整的消息转发：首先创建一个NSInvocation对象，把未处理的这条消息中的SEL、参数、目标等全部细节封装起来。（举例：触发消息前：追加另一个参数，改变选择子等等）。 (void)forwardInvocation:(NSInvocation *)invocation 最后抛出异常。 (void)doesNORecognizeSelector 13、方法交换 在运行期，可以向类中新增或替换SEL所对应的方法实现。常用作向原有实现中添加新功能。 14、类对象 用类型信息查询方法确定对象类型，不要直接比较类对象，因为某些对象可能实现了消息转发功能。 16、全能初始化方法 若全能初始化方法与超类不同，则需覆写超类中的对应方法。 17、description 若想在调试时(po命令)打印出更详尽的对象描述信息，则应实现debugDescription方法。 18、尽量使用不可变对象 只读的属性，可以通过KVC修改。 不要把可变的集合作为属性公开，而应提供相关方法。 19、命名规则 给私有方法的名称加上前缀，这样可以很容易将其同公共方法区分开。 21、错误模型 一般不抛出异常，如果抛出异常，那么本应在作用域末尾释放的对象现在却不会释放了。 22、理解NSCopying协议 如果想令自己的类支持拷贝操作，就要实现NSCopying协议，重写 - (id)copyWithZone: (NSZone *)zone 方法 如果自定义的对象分为可变版本和不可变版本，那么就要同时实现NSCopying 与 NSMutableCopying协议。 如果所写的对象需要深拷贝，可考虑新增一个专门执行深拷贝的方法。 23、delegate 在调用delegate对象中的方法时，总是应该把发起委托的实例也一并传入方法中，这样delegate对象在实现相关方法时，就能根据传入的实例分别执行不同的代码了。 当某一个对象需要从另外一个对象中获取数据时，可是使用委托模式，这种情景下，该模式也称“数据源协议”。 可用含有位段的结构体缓存委托对象是否能响应相关协议方法。 24、category 使用分类机制把类的实现代码划分成易于管理的小块。 将应该视为“私有”的方法归入名叫private 的分类中，以隐藏实现细节。 将分类方法加入类中这一操作是在运行期系统加载分类时完成的，运行期系统会把分类中所实现的每个方法都加入类的方法l列表中。 向第三库添加分类时，总应给其名称和其中的方法名加上你专用的前缀。 尽量不要将属性定义在分类中，因为分类不能合成实例变量，若真这样做了，则可以使用消息转发机制在runtime拦截方法中提供其实现，或者使用关联对象。 class-continuation分类是唯一能声明实例变量的分类。 28、通过协议提供匿名对象 具体的对象类型可以淡化成遵从某协议的id类型，协议里规定了对象所应实现的方法。 使用匿名对象隐藏类型名称（类名）。 如果具体类型不重要，重要的是对象能够响应特定方法，那么可使用匿名对象来表示。 29、ARC 在iOS应用程序中的根对象是UIApplication对象，是应用程序启动时创建的单例。 释放操作会在清空最外层的自动释放池时执行，除非你有自己的自动释放池，否则这个时机指的就是当前线程的下一次事件循环。 在ARC环境下手动调用 retain release autorelease dealloc 是非法的。 ARC在调用上述方法时，并不通过普通的OC消息派发机制，而是直接调用其底层C语言版本，这样做性能更好。 在编译期，ARC会把能够互相抵消的retain、release、autorelease操作约简。如果发现在同一个对象上执行了多次“保留”与释放操作，那么ARC有时可以成对地移除这两个操作。 ARC会自动在 .cxx_destruct方法中生成代码并运行dealloc方法来清理实例变量。 由方法所返回的对象，其内存管理语义总是通过方法名来体现。 35、僵尸对象 系统在回收对象时，可以不将其回收，而是把它转化为僵尸对象，通过环境变量NSZombieEnabled可开启此功能。 系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象，僵尸类 能够响应所有的SEL,响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序。 36、为什么不用retainCount 第一：它所返回的保留计数只是某个给定时间点上的值，该方法并未考虑到系统会稍后把自动释放池清空。 第二：有时系统会优化对象的释放行为，在保留计数还是1的时候就把它回收了。（系统在调用底层release方法时，引用计数不减一，直接回收内存）。 NSString *string = @”something”; 在这种情况下，编译器会把NSString对象所表示的数据放到应用程序的二进制文件里，这样的话，运行程序时就可以直接用了，无须再创建NSString对象。 37、Block 块与函数类似，只不过是直接定义在另一个函数里的，和定义它的那个函数共享同一范围内的东西。 块的强大之处在于：在声明它的范围里，所有变量都可以为其所捕获。 块的内部结构： 全局块不会捕捉任何状态（比如外围的变量等） 用Handler块时把处理成功情况和失败情况所用的代码全放在一个块里可以共享同一份错误处理代码。 41、GCD、NSOperation 可使用串行同步队列代替同步块或锁对象。 performSelecotr系列方法无法确定要执行的选择子具体是什么，所以ARC编译器无法插入适当的内存管理方法。 performSelecotr系列方法能处理的选择子太过局限，选择子的返回值类型及发送给方法的参数个数都受到限制。 GCD是纯C的API，而操作队列是OC对象。 使用NSOperation及NSOperationQueue的好处： 取消某个操作 指定操作间的依赖关系 可以使用KVO机制监控 NSOperation对象的属性 指定操作的优先级 重用NSOperation对象 一系列任务可归入一个dispatch group之中，开发者可以在这组任务执行完毕时获得通知。 使用dispatch_once()函数实现单例模式，由于每次调用时都必须使用完全相同的标记，所以标记要声明成static；此函数采用的是原子访问，没有使用重量级的同步机制。 ` + (id)sharedInstance{ static LLZClass *sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedInstance = [[LLZClass alloc]init] }); return sharedInstance; } dispatch_get_current_queue 可做调试之用 47、系统框架 框架的定义：将一系列代码封装为动态库，并在其中放入描述其接口的头文件，这样作出来的东西叫框架。 常用的遍历方式： for 循环 快速遍历（某个类的对象想支持快速遍历，需遵从名为NSFastEnumeration的协议） 基于块的遍历方式（可以从块里获取更多信息如：当前迭代的对象、下标、指向停止迭代的布尔值指针；其本身就能通过GCD来并发执行遍历操作） ` (void)enumerateObjectsUsingBlock:(void(^)(id object, NSUInteger idx, BOOL *stop))block 通过无缝桥接技术，可以在Foundation框架中的OC对象与CoreFoundation框架中的C语言数据结构之间来回切换。 实现缓存应选用NSCache而非NSDictionary对象，因为NSCache提供自动删减功能，而且是线程安全的，它与字典不同，不会拷贝键。 NSPurgeableData与NSCache搭配使用，可实现自动清除数据的功能。 51、load、initialize load方法不参与覆写机制，类的load方法要比分类中的先调用。 首次使用某个类之前，系统会向其发送initialize消息，由于此方法遵从覆写规则，所以通常要在里面判断当前要初始化哪个类。 load与initialize应该实现的精简些，有助于保持应用的响应能力，也能减少引入”依赖环“的几率。 无法在编译期设定的全局变量，可以放在initialize方法里初始化。 52、NSTimer NSTimer 对象会保留其目标，直到计时器本身失效为止，调用invalidate方法可令计时器失效，另外，一次性的计时器在触发完任务之后也会失效。 反复执行任务的计时器很容易引入保留环，可用块来打破保留环。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网]]></title>
    <url>%2F2018%2F02%2F24%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[仅供学习使用（内含安卓版、iOS版、Windows版、Mac版） 安卓版步骤一：下载SSR客户端 链接: 下载地址 提取密码: 16tp 初始界面 步骤二：配置方法一：二维码（推荐） 点击shadowsocksR 方法二：手动配置 配置界面（只用配置一次） 1、输入ip地址 2、输入端口号 3、输入密码 4、加密方法选aes-256-cfb 5、协议选：auth_sha1_v4 6、混淆选：plain 7、路由选：仅代理中国大陆无法访问的地址 步骤三：完成！ 点击连接 愉快的学习！！！ iOS版步骤一：下载ss客户端 前往App Store 下载FirstWingy软件 步骤二：配置 输入相应的服务器、端口号、密码即可 步骤三：完成！ 点击连接 愉快的学习 Mac版步骤一：下载ss客户端 下载地址 步骤二：配置 输入相应的服务器、端口号、密码即可 步骤三：完成！ 点击连接 愉快的学习 Windows版步骤一：下载ssr客户端 下载地址 步骤二：配置方法一：扫二维码形式 打开下载的ssr客户端，右键图标，之后的操作看图！ 方法二：手动配置 配置方式和Mac版相同 输入相应的服务器、端口号、密码即可 步骤三：完成！ 点击连接 愉快的学习]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[软件项目管理笔记]]></title>
    <url>%2F2018%2F01%2F12%2F%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[项目管理概述 项目就是为了创造一个唯一的产品或提供一个唯一的服务而进行的临时性努力。 项目特征 目标性：达成某一目的，例如完成一个学生成绩管理系统。 相关性：例如举办一个野餐活动，首先选好地点，才能前往地点进行野餐。 临时性：要在给定的时间完成任务。 独特性：例如每个学校都有自己的学生管理系统，但该系统总会有点差别。有自己的独特性。 资源约束性：资源是有限的，例如做一个学生成绩管理系统，不可能全球的开发者都为你服务。 不确定性：开发者做到一半跑路了。 软件项目除了具备项目的基本特征之外，还有自己的特殊性 软件项目特殊性 软件是一种逻辑实体。 相互作用的系统。 变更，如需求变更。 渐进明细，因为项目的独特性和临时性。 项目管理是项目随着时间的进行，为了确保项目能达到预期结果的一系列管理行为。而软件项目管理 = 项目管理 + 软件项目 + 经验技巧 + …. 项目管理知识体系10个知识领域 集成管理（Integration Mgt），成功的关键，贯穿整个项目。 范围管理 (Scope Mgt)，定义需要完成的工作。 时间管理 (Time Mgt)，保证按时完成。 成本管理 (Cost Mgt)，保证项目所花费的成本不超过预算成本。 质量管理 (Quality Mgt)，保证满足需求。 人力资源管理 (HR Mgt)，充分发挥参与项目人员的积极性。 沟通管理 (Communication Mgt)，确保信息的正确传递。 风险管理 (Risk Mgt)，降低项目失败的概率。 采购管理 (Procurement Mgt)，为了满足项目需求，从外部获取资源。 干系人管理 (Stakeholder Mgt)，分析所有对项目造成影响的人，解决利益冲突。 5个标准化过程 启动过程组 计划过程组 执行过程组 控制过程组 收尾过程组 项目确立项目立项 明确项目的目标、时间表、项目使用的资源和经费，而且得到执行该项目的项目经理和项目发起人的认可。 项目决策：采购？自主研发？外包开发？ 项目招投标 甲方招标书定义 -&gt; 乙方拿到招标书进行项目分析 -&gt; 乙方竞标准备 -&gt; 招标竞标 -&gt; 合同签署。 项目章程 正式的授权项目，任命项目经理，说明项目背景、来源、约束等，通常由项目发起人、高管等签发。 项目经理的职责 开发计划 组织实施 项目控制 生存期模型 描述了开发的主要阶段 定义每一个阶段要完成的主要过程和活动 确定每一个阶段的输入和输出 瀑布模型 瀑布模型的流程为：需求分析 -&gt; 设计 -&gt; 实施 -&gt; 测试 -&gt; 维护 需求明确 方案明确 短期项目 V模型 是一种强调测试重要性的模型，是瀑布模型的变种。其中，详细设计—单元测试；总体设计—集成测试；需求分析—系统测试；用户需求—接受测试。 需求明确 方案明确 系统性能、安全等有严格要求 快速原型模型 是在需求阶段快速构建一部分系统的生存期模型，其流程：需求分析 -&gt; 原型开发 -&gt; 原型评价 -&gt; 最终系统设计 -&gt; 最终系统实现 需求不明确 希望减少项目需求的不确定性 增量模型 将需求分段，先完成核心功能的开发，之后交给用户进行评价，经过评价之后形成下一个增量模型的开发计划，它包括对核心产品的修改和一些新功能的发布，直到产生最终的完善产品。 需求基本明确，可能发生变化 对于市场和用户把握需要逐步了解 系统改造需要一步步实施 渐进式阶段模型 具有渐进式前进、阶段式提交的特点。适用中大型项目。 优点⬇️ 阶段式提交一个可运行的产品 关键功能更早出现 早期预警问题，避免缺陷蔓延 阶段性完成可以降低估计失误 缺点⬇️ 需要精心规划各个阶段的目标 每阶段提交的都是正式版本，工作量增加 敏捷模型 不同于传统型开发模型，它更加灵活，可以应对迅速变化的需求，是一种迭代。循序渐进的开发方法。 scrum-燃尽图 有利于工作量的预估 极限编程-xp 实施原则：快速反馈、假设简单、包容变化 软件需求软件需求定义 需求是指用户对软件的功能和性能的要求。它有三个不同的层次。 业务需求:反映了客户对系统的高层次要求 用户需求：用户通过该软件要完成的任务 功能需求：开发人员必须实现的软件功能 软件需求规格：充分描述软件系统必须实现的软件功能 需求管理过程 需求获取 -&gt; 需求分析 —&gt; 需求规格编写 -&gt; 需求验证 -&gt; 需求变更 需求分析是为用户所看到的系统建立一个概念模型，是对需求的抽象描述 一份完整、规范的需求规格说明书是需求分析完成的一个基本标志 需求变更 确定需求变更控制过程 建立变更控制委员会(SCCB) 进行需求变更影响分析 跟踪所有受需求变更影响的工作产品 建立需求基准版本和需求控制版本文档 维护需求变更的历史记录 跟踪每项需求的状态 衡量需求稳定性 需求建模方法 原型方法，即需求分析，原型开发，原型评价之间的转移。 结构化分析法，包括数据流图、数据字典、系统流程图。 面向对象的用例分析法，即用例图、顺序图、状态图、活动图。 基于面向对象的情景分析方法 从用户角度出发考虑的功能需求 用例是系统向用户提供一个有价值的结果的某项功能 功能列表法，即列出所有子功能并给予描述 任务分解 将一个项目分解为更多的子项目，使项目变得更小、更易管理、更易操作,任务分解结果：WBS（Work Breakdown Structure:任务分解结构） WBS和工作包 WBS是对项目由粗到细的分解过程。 面向交付成果的 WBS它组织并定义了整个项目范围 WBS的最低层次的可交付成果 工作包应当由唯一主体负责 任务分解形式 清单形式 图表形式 任务分解过程任务分解基本步骤 确认并分解项目的组成要素(WBS编号) 确定分解标准 确定分解是否详细 确定项目交付成果（可以编制WBS字典） 验证分解的正确性 任务分解的标准 统一，不能有双重标准 最底层的要素是否是实现目标的充分必要条件 最底层要素是否有重复的 每个要素是否清晰完整定义 最底层要素是否有定义清晰的责任人 是否可以进行成本估算和进度安排 WBS任务分解建议 最低层是可控的和可管理的，但是不必要的过细 每个工作包必须有一个提交物 定义任务完成的标准 有利于责任分配 推荐任务分解到40小时以内 WBS字典 对工作包的阐述，也可以包括其他信息，如进度表的日期，成本预算。 任务分解方法 模板参照方法：很多领域都有标准的WBS，可以当作模板参考使用 类比方法：一些企业保存一些项目的WBS库为其他项目的开发提供参照 自顶向下：将一个项目逐步分解成许多子项目，是创建WBS的最好方法 自底向上：适合陌生的项目 成本计划成本估算过程 关于估算，估算不是很准确，有误差，项目经验数据非常重要，不要迷信某些数学模型 软件项目规模 软件项目规模也称工作量 软件规模单位：源代码长度（LOC）、功能点（FP）、人月、人天、人年 软件项目成本 完成软件规模付出的代价 待开发软件项目需要的资金 人的劳动的消耗所需代价是软件成品的主要成本。 成本的单位：RMB、Dollar 软件规模和软件成本的关系 规模是成本的主要因素，是成本估算的基础 有了规模就确定了成本 成本估算结果 直接成本 与具体项目相关的成本，例如参与项目的人员成本 间接成本 房租水电、管理费等 成本估算方法代码行估算法 从软件程序量的角度定义项目规模，与具体的编程语言有关，功能分解的足够详细，有类似项目的开发经验。 优点：代码是所有软件开发项目都有的“产品”，而且很容易计算代码行数。 缺点： 1、对代码行没有公认的可接受的标准定义 2、代码行数量依赖于所用的编程语言和个人的编程风格. 3、在项目早期,需求不稳定、设计不成熟、实现不确定的情况下很难准确地估算代码量. 4、代码行强调编码的工作量,只是项目实现阶段的一部分 功能点估算法 与实现的语言和技术没有关系，用系统的功能数量来测量其规模，通过评估、加权、量化得出功能点。 功能点公式：FP = UFC * TCF UFC-未调整功能点计数 外部输入：给软件提供面向应用的数据的项（如屏幕、表单、对话框、控件，文件等。 外部输出：向用户提供(经过处理的)面向应用的信息，例如，报表和出错信息等。 内部逻辑文件：用户可以识别的一组逻辑相关的数据，而且完全存在于应用的边界之内，并且通过外部输入维护，是逻辑主文件的数目。 外部接口文件：用户可以识别的一组逻辑相关数据，这组数据只能被引用。用这些接口把信息传送给另一个系统。 外部查询：一个输入引出一个即时的简单输出。没有处理过程。 TCF-技术复杂度因子 TCF = 0.65 + 0.01(sum(Fi))。 0 ≤ Fi ≤ 5 0.65 ≤ TCF ≤ 1.35 Fi一共14项。 用例点估算法用例点估算方法的基本步骤: 计算未调整的角色的权值UAW; 计算未调整的用例的权值UUCW; 计算未调整的用例点UUCP(unadjusted use case weight); 计算技术和环境因子TEF(technical and environment factor); 计算调整的用例点UCP; 计算工作量。 UUCP = UAW + UUCW TCF = 0.6 + (0.01 SUM(WV)) 有13项 ECF= 1.4 + (-0.03 SUM(WV)) 有8项 TEF = TCF + ECF UCP = UUCP * TEF 工作量（effort） = UCP * PF(项目生产率) 类比估算法（自顶向下）估算人员根据以往的完成类似项目所消耗的总成本（或工作量），来推算将要开发的软件的总成本（或工作量），然后按比例将它分配到各个开发任务单元中 有类似的历史项目数据 信息不足（例如市场招标）的时候 要求不是非常精确估算的时候 自下而上估算法 利用任务分解图(WBS),对各个具体工作包进行详细的成本估算,然后将结果累加起来得出项目总成本。 相对比较准确，它的准确度来源于每个任务的估算情况 花费时间 参数估算法 通过项目数据,进行回归分析,得出回归模型 通过参数模型估算(规模)成本的方法。 具有良好的项目数据为基础（使用条件） 存在成熟的项目估算模型（使用条件） 比较简单,而且也比较准确（特点） 如果模型选择不当或者数据不准,也会导致偏差（特点） 回归分析模型分为两类，一类是静态单变量模型，另一类是动态多变量模型。 整体公式:E = a + b * S^c E:以人月表示的工作量 a,b,c:经验导出的系数 S:主要的输入参数(通常是LOC,FP等) Walston-Felix模型 E ＝ 5.2 × (KLOC)^0.91， KLOC是源代码行数，E是工作量（以PM计） D ＝ 4.1 × (KLOC)^0.36，D是项目持续时间(以月计) S ＝ 0.54 × E^0.6，S是人员需要量(以人计) DOC ＝ 49 × (KLOC)^1.01 ，DOC是文档数量(以页计) COCOMO模型 COCOMO 81 模型级别基本COCOMO：静态单变量模型 E= a * (KLOC) ^ b 中等COCOMO：基本模型基础上考虑影响因素，调整模型 E= a (KLOC) ^ b 乘法因子 高等COCOMO：中等COCOMO模型基础上考虑各个步骤的影响 COCOMO 81 项目类型 有机 嵌入式 半有机 COCOMO || 应用组装模型—规划阶段 早期设计模型—设计阶段 后体系结构模型—开发阶段 专家估算法 由多位专家进行成本估算，一个专家可能会有偏见，最好由多位专家进行估算，取得多个估算值,最后得出综合的估算值 Ei = (ai + 4*mi + bi) / 6 项目总估算成本 = 直接成本 + 间接成本 成本预算 成本预算是将项目的总成本按照项目的进度分摊到各个工作单元中去；成本预算的目的是产生成本基线 分配资源成本：设置加班费率。 分配固定资源成本：项目中一个兼职人员成本。 分配固定成本：外包任务。 进度计划重要性 按时完成项目是项目经理最大的挑战之一;时间是项目规划中灵活性最小的因素;进度问题是项目冲突的主要原因 进度是对执行的活动和里程碑制定的工作计划日期表 任务是确定为完成项目的各个交付成果所必须进行的诸项具体活动 任务间关系的依据 强制性依赖关系。例如，测试活动一定要在编码任务之后进行。 软逻辑关系。例如哪一个模块先做哪一个模块后做。 外部逻辑关系。例如环境测试依赖于外部提供的环境设备。 进程管理图示网络图 网络图是活动排序的一个输出,展示项目中各个活动以及活动之间的逻辑关系 PDM:优先图法 ,节点法 (单代号)网络图 节点(Box)表示活动（任务） 用箭线表示各活动(任务)之间的逻辑关系 ADM:箭线法、双代号网络图 箭线表示活动(任务) 两个代号唯一确定一个任务 代号表示前一任务的结束,同时也表示后一任务的开始 虚活动：为了表示逻辑关系、不消耗资源的 甘特图 分为棒状甘特图、三角形甘特图 里程碑图 显示项目进展中的重大工作完成情况。不同于活动，活动需要消耗资源，而里程碑不消耗资源和时间。 资源图 显示资源分配的情况 任务历时估算 定额估算法 T=Q/(R*S) T:活动历时 Q:任务工作量 R:人力数量 S:工作效率 经验导出模型 经验导出模型：D=a*E^b： D:进度(以月单位) E：工作量(以人月单位) a:2—4之间 b:1/3左右:依赖于项目 CPM(关键路径法估计) PERT(工程评估评审技术) 期望值E=（O+4m+P)/6 O是最小估算值:乐观(Optimistic)， P是最大估算值:悲观(Pessimistic)， M是最大可能估算(Most Likely) 标准差δ =(最大估算值-最小估算值)/6 方差δ 2 = [(最大估算值-最小估算值)/6]^2 基于承诺的进度估计 Jones的一阶估算准则 进度计划编排关键路径法 自由浮动时间：在不影响后置任务最早开始时间的前提下，一个任务可以延迟的时间 时间压缩法 应急法：压缩时间、压缩成本 平行作业法：对任务进行合理拆分，如提前某些任务 管理预留 设置缓冲时间 资源平衡 调整任务的时间来协调资源的冲突 敏捷计划 迭代周期 质量计划 质量是满足要求的程度,包括符合规定的要求和满足顾客隐含需求 软件质量是软件满足明确说明或者隐含的需求的程度 质量形成于产品或者服务的开发过程中，而不是事后的检查（测试）把关等 质量成本是由于产品的第一次工作不正常而衍生的附加花费，包括预防成本、缺陷成本 软件质量模型 Boehm质量模型 McCall质量模型 ISO质量模型 质量管理的对象：过程质量、产品质量 软件质量管理过程 软件质量计划 软件质量保证 软件质量控制 质量计划方法 试验设计 基准对照 质量成本分析 流程图方法 因果分析图 配置管理计划 记录软件产品的演化过程；得到精确的产品配置；最终保证软件产品的完整性、一致性、追朔性、可控性 配置管理的主要功能 版本管理 变更管理 一些概念 配置项：受控于软件配置管理的款项 基线提供了软件生存期中各个开发阶段的一个特定点 一个(些)配置项形成并通过审核，即形成基线 基线标志开发过程一个阶段的结束和里程碑 基线修改需要按照正式的程序执行 配置管理的基本过程 配置标示、跟踪 配置管理环境建立 基线变更管理 配置管理审计 配置状态统计 配置管理计划 软件项目与人员沟通计划组织结构的主要类型职能型 优点 可以充分发挥职能部门的资源集中优势 部门的专家可以同时为部门内不同项目使用 便于相互交流 , 相互支援 可以随时增派人员 可以将项目和本部门的职能工作融为一体 缺点 项目和部门利益发生冲突，职能部门更重视本部门目标,会忽视项目目标 资源平衡会出现问题 权利分割不利于各个职能部门的交流和团结协作 行政隶属关系使得项目经理没有充分的权利项目型 优点 项目经理对项目可以负全责 项目目标单一，可以以项目为中心,有利于项目顺利进行 避免多重领导 组织结构简单，交流简单,快速 缺点 资源不能共享 各个独立的项目处于相对封闭状态,不利于公司政策的贯彻 对项目组织的成员缺少一种事业上的连续性和安全感 项目组织之间处于分割状态,缺少信息交流 矩阵型 优点 专职的项目经理负责整个项目 , 以项目为中心, 公司的多个项目可以共享各个职能部门的资源 即利于项目目标的实现,又利于公司目标方针的贯彻 项目成员的顾虑减少了 缺点 容易引起职能经理和项目经理权力的冲突 资源共享也能引起项目之间的冲突 干系人管理计划 干系人（stakeholder）是能影响项目决策、活动或者结果的个人、群体或者组织，以及会受到或者自认为会受到项目决策、活动或者结果影响的个人、群体或者组织 识别出干系人，分析和记录他们的相关信息。例如联络信息、他们的利益、参与度、影响力、以及对项目成功的潜在影响。 项目沟通的基本原则 及时性 准确性 完整性 可理解性 项目沟通的方式 书面沟通和口头沟通 语言沟通和非语言沟通 正式沟通和非正式沟通 单向沟通和双向沟通 网络沟通 项目沟通计划 沟通计划是确定谁需要信息，需要什么信息，何时需要信息，以及如何将信息分发给他们 风险计划风险类型 预测角度：已知风险、可预测风险、不可预测风险 范围角度：商业风险、管理风险、人员风险、技术风险、开发环境风险、客户风险、过程风险、产品规模风险等。 风险识别 风险识别是试图通过系统化地确定对项目计划的威胁，识别已知和可预测的风险。 风险识别方法 德尔菲方法 头脑风暴法 情景分析法 利用风险条目检查表 风险评估 对风险事件发生概率的评估，对项目风险影响的评估，给出项目风险排序。 定性风险评估 定量风险评估 盈亏平衡分析 模拟 决策树分析：是一种图表分析方法；提供项目所有可供选择的行动方案，行动方案之间的关系，行动方案的后果以及发生的概率；提供选择一个最佳的方案的依据。 EMV (损益期望值) 风险规划 针对风险分析的结果，为提高实现项目目标的机会，降低风险的负面影响而制定风险应对策略和应对措施的过程，即制定一定的行动和策略来对付、减少、以至于消灭风险事件造成的影响。 风险应对策略 回避风险：例如放弃采用新技术。 转移风险：例如开脱责任合同。 损失控制 损失预防：例如项目技术培训。 损失抑制：项目人员储备 自留风险：由项目组织自己承担风险事故所致损失的措施 合同计划项目采购 为了执行项目而从项目团队外部获取产品、服务或者结果的过程. 合同类型 成本补偿合同 成本加成本百分比 成本加固定费用 成本加奖金 固定价格合同 固定价格加奖励费 固定总价 单价合同 工程师单价:130美元/工时 产品单价:1500元/功能点 集成计划软件项目管理最重要的四个要素 范围、质量、进度、成本 范围和成本正比关系。 质量和成本正比关系。 进度和成本反比关系。 集成计划执行控制项目执行控制的步骤 建立标准 采集项目实际数据（对项目管理、开发和质量活动进行跟踪。记录反映当前项目状态的数据。） 实际结果与计划比较 决定是否修正计划（根据评审结果决定是否修改项目计划，计划的不合理。客观原因导致。） 修正计划，协调各方 核心计划集成控制范围管理 范围计划的执行 需求变更的控制 时间/成本管理图解控制法 一目了然的了解项目的状况，易于理解，但最大缺点就是仅仅提供视觉印象，无法提供量化的信息 进度甘特图 资源图（资源图围住的面积代表某段工作时间的资源消耗） 费用曲线图 挣值分析法 BCWS (Budgeted cost of work scheduled)计划完成工作的预算成本 ACWP (Actual cost of work performed)已完成工作的实际成本 BCWP (Budgeted cost of work performed)工作完成的预算成本 BAC (Budget At Completion)预算总值 TAC (Time At Completion)预计完成时间 SV (Schedule Variance)进度差异 = BCWP - BCWS CV (cost variance)费用差异 = BCWP - ACWP SPI (schedule performance index)进度效能指标 = BCWP/BCWS * 100% CPI (cost performance index)成本效能指标 = BCWP/ACWP * 100% EAC (estimate at completion)项目完成的预算成本 = BAC/CPI SAC (schedule at completion)项目完成的预测时间 = TAC/SPI VAC (variance at completion)项目完成的成本差异 = BAC - EAC TCPI 未完工的成本效能指标 = 剩余工作/剩余成本 = （BAC - BCWP）/ (GOAL - ACWP)。分子是多少工作要做，分母是还有多少钱可以消费。 敏捷进度控制 燃尽图直观的反映了sprint 过程中剩余工作量情况。 质量管理质量保证 过程审计（需求过程、设计过程、编码过程） 产品审计（需求规格、设计报告、代码） 质量控制 技术评审：采用检查表的技术评审方法 代码走查 软件测试：测试是程序的执行过程，目的在于发现错误，一个成功的测试是发现了至今未发现的错误的测试。 返工：是将有缺陷的和不合格项改造为与需求和规格一致的行为 。 控制图法 趋势分析 抽样统计 辅助计划执行控制人员管理 马斯洛的需求层次理论：金字塔型，由下到上分别是生理的、安全的、自尊、自我实现 海兹伯格的激励理论包括内在因素和外在因素，其中内在因素为：成就感、责任感、晋升、被认可；外在因素为：工作环境、薪酬、工作关系、安全等 麦克勒格的 X－理论：针对懒惰性人员 麦克勒格的 Y－理论：针对勤奋性人员 超Ｙ理论 Z理论 期望理论 干系人管理沟通管理 信息技术沟通：例如利用微信 正式沟通：例如阶段性评审 非正式沟通：聊天、聚会 风险管理合同管理项目结束 当项目计划中的可交付成果已经出现，或者项目失败都将导致项目结束，项目结束意味着合同也结束咯。]]></content>
      <tags>
        <tag>软件项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白微信公众号]]></title>
    <url>%2F2017%2F12%2F19%2F%E5%B0%8F%E7%99%BD%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[首先，在需求方面上，个人觉得微信公众号本质上就是以一种服务的形式面向用户，用户在公众号上花的大部分时间都是看文章，查询资源等，例如“长江商业评论、浙商大图书馆“等。从技术层面上看，就是一系列的查询数据库操作。如果在公众号上做过多的增、删、改这种业务操作，实在是没必要。因此从一开始，我们的愿景就是仅提供给用户一些想要的数据。对于程序员来说，音乐就是编程的源泉，没思路的时候，不妨来首音乐放松下。所以我们做了一个公众号，专门提供给用户实时的音乐资源。 简述：（二维码在底部）既然是实时的音乐资源，那么就不能提供假的数据， 所以我利用了爬虫技术，从网易云音乐官网上爬取其热歌榜、新歌榜、热评等实时数据。这时就需要一些爬虫的小技巧了，我就说说我用到的一些小白爬虫技巧吧。足以能够应付以上这些需求了。 一、设置User-agent模拟浏览器，不然运维人员发现访问的ip都是同一个ip，并且User-agent都是Python程序的话。就会被限制访问了。 二、获取代理ip爬取数据，如果同一个ip访问次数过于频繁也会被限制（深受其害…） 三．设置延时访问（试过，Python本身运行就慢，再设置这个，更慢…）爬取热歌榜、新歌榜还是比较轻松的，因为只用访问一次。但是热评就不一样了，有多少音乐id，就要访问多少次。很容易被限制访问。我成功测试了连续访问200次。 菜单栏中的音乐宝库按钮，采用的是内置网页的形式，其中用了微信团队研发的WEUI框架，使用的时候出现了一些小瑕疵，引入navbar的时候并不像demo所示的那种效果，我的解决办法就是重写它的部分css就可以了。今日热评和今日歌曲就用rand()函数随机返回几条数据就行了。 遇到的一个大坑：从数据库返回数据的时候，拼接过程中，不小心在每个url的前面加了换行符…然后就深陷Bug中无法自拔了。 还有一个小坑：js传参数的时候，只能传数字，原因：没转义….（php,html各种穿插真的难写）。 不足之处：功能比较简约，缺少时效性。 总结：以上，就是我在制作“十月音乐盒”公众号时，从设计到实现遇到的一些问题与见解。 二维码在这！]]></content>
      <categories>
        <category>微信公众号</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿知乎广告植入]]></title>
    <url>%2F2017%2F12%2F01%2F%E4%BB%BF%E7%9F%A5%E4%B9%8E%E5%B9%BF%E5%91%8A%E6%A4%8D%E5%85%A5%2F</url>
    <content type="text"><![CDATA[前天夜晚，我也像往常一样刷着知乎，正当我困意十足，准备睡觉时，突然一个神奇的cell吸引了我的注意力。仔细一看，原来是知乎植入的广告，这种植入方式，真的是太有创意了emmmmmmmmm。所以我打算模仿一下 效果图： ​ 这种植入广告的方式真的很赞，仅用有限的区域，就能展示一个全屏的广告，很多用户可能会对这种cell很新奇，便会点击进去，就比如我emmmmmm demo地址：https://github.com/Liulinzhe17/ZhihuAds 正文：整体的思路还是很清晰的，就是一个tableview里有两种不同类型的tableviewcell，一种是内容cell，一种是广告cell，当广告cell可视的时候，其背景色设为透明，并且将tableview的背景设置成广告图片，当广告cell离开屏幕时，将tableview的背景视图设为nil即可。 其中要注意的一些点： 将广告cell 背景色改成透明 1adscell.backgroundColor=[UIColor clearColor]; tableviewcell的高度要根据内容自适应，仔细观察会发现知乎的内容简介最多不超过三行，所以我 设置了UIlabel最大行数。 1label.numberofLines=3; tableviewcell里的contentView中内容高度不固定的，要设置其上下左右约束。 123//cell高度随内容自适应_tableview.estimatedRowHeight=100;//估算内容高度_tableview.rowHeight=UITableViewAutomaticDimension; ​ 当广告cell进入屏幕时，将此时tableview的背景图片改成广告图片，当广告cell离开屏幕时，将背景图片置空即： 1234567//判断广告cell是否在屏幕上- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath&#123; if ([types[indexPath.section]intValue]==0) &#123; //移除广告背景图片 self.tableview.backgroundView=nil; &#125;&#125; 当点击广告cell时，要判断此时广告cell所处的坐标，然后广告图片从广告cell所处的位置出发，渐渐的扩大到整个屏幕。（PS：其实有更加好的做法，就是再添加两个掩盖层，一个往上收，一个往下收，这样效果会好一点，不会有图片被压缩的感觉） 123 //获取tableviewcell相对父视图的位置CGRect rectInTableView = [tableView rectForRowAtIndexPath:indexPath];CGRect location = [tableView convertRect:rectInTableView toView:[tableView superview]]; 结尾点击广告cell的处理还有一些问题，个人觉得应该是将广告cell扩大到整个屏幕，而不是添加一个子视图这种蠢操作。。。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JPA 映射双向多对多的问题]]></title>
    <url>%2F2017%2F11%2F28%2FJPA%2F</url>
    <content type="text"><![CDATA[本文主要解决的问题：用jpa实现两张表（多对多关联）的时候碰到Expected ‘:’ instead of ‘t’的错误 以及一大堆的jackson errors 关于jpa怎么实现两个多对多的表之间的关联，网上已经有一大堆博客讲的非常详细了,可参考 详细版 https://www.cnblogs.com/lj95801/p/5011537.html 简约版 http://blog.csdn.net/lewis_007/article/details/53006602 例子学生实体 12345678910111213141516171819202122232425262728@Entitypublic class Student &#123; @Id private Integer stuId; private String name; @ManyToMany(cascade = CascadeType.ALL) @JoinTable(name = &quot;中间表的名字&quot;, joinColumns = &#123; @JoinColumn(name = &quot;stuId&quot;, referencedColumnName = &quot;stuId&quot;)&#125;, inverseJoinColumns = &#123; @JoinColumn(name = &quot;courseId&quot;, referencedColumnName = &quot;courseId&quot;)&#125;) private Set&lt;Course&gt; courses; public Student() &#123; &#125; public Set&lt;Course&gt; getCourses() &#123; return courses; &#125; public void setCourses(Set&lt;Course&gt; courses) &#123; this.courses = courses; &#125; ...other setters and getters&#125; 课程实体 12345678910111213141516171819202122232425@Entitypublic class Course &#123; @Id private Integer courseId; private String name; @ManyToMany(mappedBy = &quot;courses&quot;) private Set&lt;Student&gt; students; public Course() &#123; &#125; public Set&lt;Student&gt; getStudents() &#123; return students; &#125; public void setStudents(Set&lt;Student&gt; students) &#123; this.students = students; &#125; ...other setters and getters&#125; 控制器 123456@RequestMapping(value=&quot;/list&quot;, method=RequestMethod.GET)@ResponseBodypublic List&lt;Student&gt; list() &#123; List&lt;Student&gt; stu = stuService.findAll(); return stu;&#125; 当我用postman请求这个接口的时候，返回的是Expected ‘:’ instead of ‘t’，控制台也会出现以下错误： 123[jackson-databind-2.6.6.jar:2.6.6] at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:693) ~[jackson-databind-2.6.6.jar:2.6.6] at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:675) ~[jackson-databind-2.6.6.jar:2.6.6].....省略.... 原因为什么会出现这个问题呢？我们看看源码，很容易就发现当请求返回Student列表时，学生类里的courses属性会引用Course类，而Course类里students属性又会引用Student类，因此造成了循环引用。 解决办法用@JsonIgnoreJsonIgnore注解主要用于属性或者方法上，作用就是忽略属性或者方法，此处用在了getStudents（）方法上只需在课程实体类的 getStudents()方法上加一行代码,即： 1234@JsonIgnorepublic Set&lt;Student&gt; getStudents() &#123; return students;&#125; 结尾Stack Overflow大法好😄]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>jpa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[误删了Assets.xcasetts]]></title>
    <url>%2F2017%2F09%2F23%2F%E8%AF%AF%E5%88%A0%E4%BA%86Assets-xcasetts%2F</url>
    <content type="text"><![CDATA[今天在删除文件的时候，一不小心手贱就把Assets.xcasetts删除了，淡定的我默默的打开了废纸篓，拖了回去🤷‍♀️，没想到，打开app后发现所有的图片都不显示了。。。 解决办法 1.打开废纸篓，将Assets.xcasetts放回原处 2.找到Assets.xcasetts所在的目录，将其移到桌面 3.回到xcode，new -&gt; File…-&gt; Resource -&gt;Asset Catalog 将其命名为Assets.xcasetts 4.退出xcode，把桌面上的Assets.xcasetts替换掉项目里新创建的Assets.xcasetts 5.你可以继续愉快的编程了😄 （如果还不行的话，那就只能把所有图片重新拖到新创建的Assets.xcasetts里了）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>xcode</tag>
      </tags>
  </entry>
</search>
